<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Professional Image Detector</title>
  <meta name="description" content="In-browser object detection (COCO-SSD) with upload, drag-drop and live camera. Accessible & responsive.">
  <style>
    :root{
      --bg:#071029; --card:#081220; --muted:#9aa6b2; --accent:#4f46e5; --glass: rgba(255,255,255,0.03);
      --radius:12px; --pad:14px; --text:#e6eef6;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      font-size:14px;
    }
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#02101a 140%);color:var(--text)}
    .container{max-width:1100px;margin:20px auto;padding:16px;display:grid;grid-template-columns:1fr 360px;gap:18px}
    @media (max-width:900px){.container{grid-template-columns:1fr;padding:12px}}
    .card{background:linear-gradient(180deg,var(--card), #041220);border-radius:var(--radius);padding:var(--pad);box-shadow:0 10px 30px rgba(2,6,23,0.6)}
    header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
    header h1{font-size:18px;margin:0}
    .top-controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button, input[type=range], select{appearance:none;border:0;padding:8px 12px;border-radius:8px;background:var(--glass);color:inherit;cursor:pointer}
    .btn-primary{background:linear-gradient(90deg,var(--accent),#7c3aed);box-shadow:0 6px 18px rgba(79,70,229,0.18)}
    .btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.04)}
    .viewer{position:relative;border-radius:10px;overflow:hidden;background:#031423;display:flex;align-items:center;justify-content:center;min-height:440px}
    #preview, #video {max-width:100%;height:auto;display:block}
    #overlay{position:absolute;left:0;top:0;pointer-events:none}
    .muted{color:var(--muted);font-size:13px}
    .sidebar .section{margin-bottom:12px}
    .result-list{max-height:360px;overflow:auto;padding-right:8px}
    .result-item{display:flex;justify-content:space-between;padding:8px;border-radius:8px;margin-bottom:6px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));font-size:14px}
    .small{font-size:12px;color:var(--muted)}
    .dropzone{width:100%;height:120px;border-radius:10px;border:2px dashed rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;text-align:center;padding:12px}
    footer{margin-top:8px;font-size:12px;color:var(--muted)}
    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    .kbd{background:rgba(255,255,255,0.04);padding:4px 8px;border-radius:6px;font-size:12px}
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Professional Image Detector">
    <main class="card" id="main">
      <header>
        <div style="width:52px;height:52px;border-radius:10px;background:linear-gradient(180deg,var(--accent),#7c3aed);display:flex;align-items:center;justify-content:center;font-weight:700">ID</div>
        <div>
          <h1>Professional Image Detector</h1>
          <div class="muted">Client-side object detection (COCO-SSD). Upload image, drag & drop or use your camera.</div>
        </div>
      </header>

      <div class="top-controls" role="region" aria-label="Controls">
        <label class="btn-ghost" tabindex="0" for="fileInput" title="Upload image">Upload image
          <input id="fileInput" type="file" accept="image/*" class="sr-only" />
        </label>

        <button id="btnCamera" class="btn-primary" aria-pressed="false" title="Start camera (or press C)">Start Camera <span class="small"> (C)</span></button>
        <button id="btnStop" class="btn-ghost" disabled title="Stop camera (or press S)">Stop Camera <span class="small"> (S)</span></button>

        <button id="btnSave" class="btn-ghost" title="Save annotated image">Save Annotated</button>
        <button id="btnExportJson" class="btn-ghost" title="Export detections as JSON">Export JSON</button>
        <button id="btnExportCsv" class="btn-ghost" title="Export detections as CSV">Export CSV</button>

        <label class="small muted" style="margin-left:auto">Confidence: <span id="confVal">0.50</span></label>
        <input id="confRange" type="range" min="0" max="1" step="0.01" value="0.5" aria-label="Confidence threshold" style="width:160px"/>
      </div>

      <section class="viewer" id="viewer" aria-live="polite" aria-label="Image and video viewer">
        <div id="dropzone" class="dropzone" tabindex="0" aria-label="Drop image here or press Enter to browse">
          <div>
            <div style="font-weight:600;font-size:16px;margin-bottom:6px">Drag & drop an image or use camera</div>
            <div class="muted">Use the upload button or drag an image file. Press C to toggle camera, S to stop.</div>
          </div>
        </div>

        <img id="preview" alt="Uploaded image preview" style="display:none" />
        <video id="video" autoplay muted playsinline style="display:none"></video>
        <canvas id="overlay"></canvas>
      </section>

      <div style="display:flex;gap:10px;margin-top:12px;align-items:center;flex-wrap:wrap">
        <div class="muted small">Model: <span id="modelState">Not loaded</span></div>
        <div class="muted small">FPS: <span id="fps">0</span></div>
        <div class="muted small">Last: <span id="lastUpdate">—</span></div>
        <div style="margin-left:auto" class="small muted">Shortcuts: <span class="kbd">C</span> start camera, <span class="kbd">S</span> stop</div>
      </div>

      <footer>
        <div class="muted">All processing is done locally. Works offline after model is cached. Model: COCO-SSD (lite).</div>
      </footer>
    </main>

    <aside class="card sidebar" aria-label="Detection results and settings">
      <div class="section">
        <div class="muted">Detections</div>
        <div id="results" class="result-list" aria-live="polite"></div>
      </div>

      <div class="section">
        <div class="muted">Debug</div>
        <div class="small">Model loaded: <strong id="modelLoaded">No</strong></div>
        <div class="small">Number of detections: <span id="detCount">0</span></div>
        <div style="margin-top:8px">
          <button id="btnClear" class="btn-ghost">Clear</button>
        </div>
      </div>

      <div class="section">
        <div class="muted">Tips</div>
        <ul class="small" style="padding-left:16px">
          <li>Good lighting improves detections.</li>
          <li>Use the confidence slider to hide low-confidence boxes.</li>
        </ul>
      </div>
    </aside>
  </div>

  <!-- TF.js + COCO-SSD -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.13.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.2/dist/coco-ssd.min.js"></script>

  <script>
    /* Professional Image Detector - Single File
       Features:
       - Upload / drag-drop
       - Camera start/stop with keyboard shortcuts
       - COCO-SSD (lite) model loaded client-side
       - Canvas overlay with labeled boxes and confidence
       - Confidence threshold filter
       - Export JSON/CSV, Save annotated PNG
       - Accessibility: ARIA, keyboard focus & shortcuts
    */

    (function(){
      // Elements
      const fileInput = document.getElementById('fileInput');
      const preview = document.getElementById('preview');
      const video = document.getElementById('video');
      const overlay = document.getElementById('overlay');
      const dropzone = document.getElementById('dropzone');
      const btnCamera = document.getElementById('btnCamera');
      const btnStop = document.getElementById('btnStop');
      const btnSave = document.getElementById('btnSave');
      const btnExportJson = document.getElementById('btnExportJson');
      const btnExportCsv = document.getElementById('btnExportCsv');
      const btnClear = document.getElementById('btnClear');
      const confRange = document.getElementById('confRange');
      const confVal = document.getElementById('confVal');
      const modelState = document.getElementById('modelState');
      const modelLoadedEl = document.getElementById('modelLoaded');
      const resultsEl = document.getElementById('results');
      const fpsEl = document.getElementById('fps');
      const lastUpdate = document.getElementById('lastUpdate');
      const detCount = document.getElementById('detCount');

      // State
      let model = null;
      let stream = null;
      let running = false;
      let rafId = null;
      let lastTime = performance.now();
      let frames = 0;
      let lastDetections = []; // store last model detections (for export)
      let videoReady = false;

      // Accessibility: expose focus for dropzone
      dropzone.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter'){ fileInput.click(); }
      });

      // Keyboard shortcuts: C to start/toggle camera, S to stop
      window.addEventListener('keydown', (e)=>{
        if(document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) return;
        if(e.key.toLowerCase() === 'c'){ // toggle start
          if(!running) btnCamera.click();
          else { /* already running */ }
        } else if(e.key.toLowerCase() === 's'){
          btnStop.click();
        }
      });

      // Update confidence display
      confRange.addEventListener('input', ()=> confVal.textContent = parseFloat(confRange.value).toFixed(2));

      // Load model early
      async function loadModel(){
        modelState.textContent = 'Loading model...';
        try{
          model = await cocoSsd.load({base:'lite_mobilenet_v2'});
          modelState.textContent = 'Loaded COCO-SSD (lite)';
          modelLoadedEl.textContent = 'Yes';
        } catch(err){
          console.error('Model failed to load', err);
          modelState.textContent = 'Load failed';
          alert('Model failed to load. See console.');
        }
      }
      loadModel();

      // Utility: draw detections on overlay canvas
      function drawDetections(dets, width, height, scaleX=1, scaleY=1){
        overlay.width = width;
        overlay.height = height;
        const ctx = overlay.getContext('2d');
        ctx.clearRect(0,0,overlay.width,overlay.height);
        ctx.font = '14px Inter, system-ui';
        ctx.textBaseline = 'top';
        dets.forEach(d=>{
          const [x,y,w,h] = d.bbox;
          const sx = x * scaleX, sy = y * scaleY, sw = w * scaleX, sh = h * scaleY;
          // box
          ctx.lineWidth = Math.max(2, Math.round(overlay.width/320));
          ctx.strokeStyle = 'rgba(255,205,50,0.95)';
          ctx.strokeRect(sx, sy, sw, sh);
          // label background
          const label = `${d.class} ${(d.score*100).toFixed(1)}%`;
          const pad = 6;
          const textW = ctx.measureText(label).width + pad*2;
          const textH = 18;
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(sx, Math.max(0, sy - textH), textW, textH);
          // text
          ctx.fillStyle = '#fff';
          ctx.fillText(label, sx + pad/2, Math.max(0, sy - textH + 2));
        });
      }

      // Update results panel and counters
      function updateResults(allDetections, threshold){
        lastDetections = allDetections; // keep full results for export
        const filtered = allDetections.filter(d => d.score >= threshold);
        // aggregate counts
        const counts = {};
        filtered.forEach(d => counts[d.class] = (counts[d.class]||0) + 1);
        // render
        resultsEl.innerHTML = '';
        detCount.textContent = filtered.length;
        if(filtered.length === 0){
          resultsEl.innerHTML = '<div class="muted small">No detections above threshold.</div>';
          return;
        }
        Object.keys(counts).sort().forEach(k=>{
          const div = document.createElement('div');
          div.className = 'result-item';
          div.innerHTML = `<div>${k}</div><div class="small">${counts[k]}</div>`;
          resultsEl.appendChild(div);
        });
      }

      // Detection on image element
      async function detectImageElement(img){
        if(!model) return;
        try{
          const preds = await model.detect(img);
          // image display size vs natural size
          const displayW = img.clientWidth;
          const displayH = img.clientHeight;
          const scaleX = displayW / img.naturalWidth;
          const scaleY = displayH / img.naturalHeight;
          const threshold = parseFloat(confRange.value);
          const filtered = preds.filter(p => p.score >= threshold);
          drawDetections(filtered, displayW, displayH, 1/scaleX, 1/scaleY); // image natural -> display scaling handled
          updateResults(preds, threshold);
          lastUpdate.textContent = new Date().toLocaleTimeString();
        } catch(err){
          console.error('Error detecting image', err);
        }
      }

      // Detection loop for video
      async function detectVideoFrame(){
        if(!running || !model) return;
        try{
          const preds = await model.detect(video);
          const displayW = video.clientWidth;
          const displayH = video.clientHeight;
          // video.videoWidth / video.videoHeight are the source dims
          const scaleX = displayW / video.videoWidth;
          const scaleY = displayH / video.videoHeight;
          const threshold = parseFloat(confRange.value);
          const filtered = preds.filter(p => p.score >= threshold);
          drawDetections(filtered, displayW, displayH, 1, 1); // model.detect(video) uses video element coords
          updateResults(preds, threshold);
          lastUpdate.textContent = new Date().toLocaleTimeString();

          // fps calc
          frames++;
          const now = performance.now();
          if(now - lastTime >= 1000){
            fpsEl.textContent = frames;
            frames = 0;
            lastTime = now;
          }
        } catch(err){
          console.error('Video detection error', err);
        }
        rafId = requestAnimationFrame(detectVideoFrame);
      }

      /* --- Upload & Drag/Drop handlers --- */
      fileInput.addEventListener('change', (e)=>{
        const f = e.target.files && e.target.files[0];
        if(!f) return;
        stopCamera();
        showImageFile(f);
      });

      // Drag handlers
      ['dragenter','dragover'].forEach(evt=>{
        dropzone.addEventListener(evt,(e)=>{ e.preventDefault(); dropzone.style.outline='2px dashed rgba(255,255,255,0.06)'; });
      });
      ['dragleave','dragend','drop'].forEach(evt=>{
        dropzone.addEventListener(evt,(e)=>{ e.preventDefault(); dropzone.style.outline='none'; });
      });
      dropzone.addEventListener('drop', (e)=>{
        const f = e.dataTransfer.files && e.dataTransfer.files[0];
        if(f && f.type.startsWith('image/')){
          stopCamera();
          showImageFile(f);
        }
      });

      function showImageFile(file){
        const url = URL.createObjectURL(file);
        preview.src = url;
        preview.style.display = 'block';
        video.style.display = 'none';
        preview.onload = () => {
          // size overlay to displayed image
          overlay.width = preview.clientWidth;
          overlay.height = preview.clientHeight;
          detectImageElement(preview);
          URL.revokeObjectURL(url);
        };
      }

      /* --- Camera control --- */
      btnCamera.addEventListener('click', async ()=>{
        if(running) return;
        try{
          stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
          video.srcObject = stream;
          video.style.display = 'block';
          preview.style.display = 'none';
          btnStop.disabled = false;
          btnCamera.disabled = true;
          running = true;
          // wait for video to have dimensions
          video.onloadedmetadata = () => {
            // size overlay to video display size
            overlay.width = video.clientWidth;
            overlay.height = video.clientHeight;
            // begin loop
            detectVideoFrame();
          };
        } catch(err){
          console.error('Camera permission/availability error', err);
          alert('Unable to access camera. Check permissions or device. You can still upload images.');
        }
      });

      btnStop.addEventListener('click', stopCamera);

      function stopCamera(){
        if(stream){
          stream.getTracks().forEach(t => t.stop());
          stream = null;
        }
        if(rafId) cancelAnimationFrame(rafId);
        running = false;
        video.style.display = 'none';
        btnCamera.disabled = false;
        btnStop.disabled = true;
        // clear overlay & results
        const ctx = overlay.getContext('2d');
        ctx && ctx.clearRect(0,0,overlay.width,overlay.height);
        resultsEl.innerHTML = '';
        detCount.textContent = '0';
        fpsEl.textContent = '0';
      }

      /* --- Save annotated image (PNG) --- */
      btnSave.addEventListener('click', ()=>{
        // compose base + overlay onto temp canvas
        const tmp = document.createElement('canvas');
        const ctx = tmp.getContext('2d');
        let w, h;
        if(preview.style.display !== 'none' && preview.src){
          w = preview.clientWidth; h = preview.clientHeight;
          tmp.width = w; tmp.height = h;
          ctx.drawImage(preview, 0, 0, w, h);
        } else if (video.style.display !== 'none' && running){
          w = video.clientWidth; h = video.clientHeight;
          tmp.width = w; tmp.height = h;
          ctx.drawImage(video, 0, 0, w, h);
        } else {
          alert('No image or video to save. Upload an image or start the camera.');
          return;
        }
        // overlay
        ctx.drawImage(overlay, 0, 0);
        tmp.toBlob((blob)=>{
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'annotated.png';
          a.click();
        }, 'image/png');
      });

      /* --- Export detections (JSON & CSV) --- */
      function exportJSON(){
        if(!lastDetections || lastDetections.length === 0){ alert('No detections to export.'); return; }
        const data = JSON.stringify(lastDetections, null, 2);
        const blob = new Blob([data], {type:'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'detections.json';
        a.click();
      }
      function exportCSV(){
        if(!lastDetections || lastDetections.length === 0){ alert('No detections to export.'); return; }
        const rows = [['class','score','x','y','width','height']];
        lastDetections.forEach(d=>{
          rows.push([d.class, d.score.toFixed(4), d.bbox[0], d.bbox[1], d.bbox[2], d.bbox[3]]);
        });
        const csv = rows.map(r => r.join(',')).join('\n');
        const blob = new Blob([csv], {type:'text/csv'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'detections.csv';
        a.click();
      }
      btnExportJson.addEventListener('click', exportJSON);
      btnExportCsv.addEventListener('click', exportCSV);

      /* --- Clear state --- */
      btnClear.addEventListener('click', ()=>{
        stopCamera();
        preview.src = '';
        preview.style.display = 'none';
        resultsEl.innerHTML = '';
        detCount.textContent = '0';
        lastUpdate.textContent = '—';
        modelState.textContent = model ? 'Loaded COCO-SSD (lite)' : 'Not loaded';
      });

      // Defensive: handle visibility change to stop camera when user leaves the tab
      document.addEventListener('visibilitychange', ()=>{
        if(document.hidden) { /* keep but you can stop to save resource */ }
      });

      // Graceful error handling for unsupported browsers
      if(!('mediaDevices' in navigator) || !('getUserMedia' in navigator.mediaDevices)){
        // disable camera button
        btnCamera.disabled = true;
        btnCamera.title = 'Camera not supported on this browser';
      }
    })();
  </script>
</body>
</html>
